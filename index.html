<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>New Year Countdown Ultimate</title>
    
    <!-- Fonts: Outfit -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap" rel="stylesheet">
    
    <!-- Icons: Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <style>
        :root {
            --bg-color: #050505;
            --text-color: #ffffff;
            --text-muted: #cccccc;
            /* Full screen glass effect variables */
            --card-bg: rgba(20, 20, 25, 0.4); 
            --card-border: rgba(255, 255, 255, 0.1);
            --accent-color: #7b2cbf;
            --accent-gradient: linear-gradient(135deg, #9d4edd 0%, #3c096c 100%);
            --glass-blur: blur(30px);
            --input-bg: rgba(0, 0, 0, 0.3);
            --success-color: #2ecc71;
            --danger-color: #ff3333;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 10%, #1a0b2e 0%, #000000 100%);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        /* High Quality Canvas */
        #fireworks-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        /* Full Screen Card with Glassmorphism */
        .container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            background-color: var(--card-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            padding: 2vh 4vw; /* 高さに応じてパディング調整 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            transition: opacity 0.5s ease, transform 0.5s ease;
            overflow-y: auto; /* 画面が極端に小さい場合はスクロール */
            border: 1px solid rgba(255,255,255,0.05);
        }
        
        .container.hidden {
            opacity: 0;
            transform: scale(1.05);
            pointer-events: none;
        }

        /* Inner content wrapper to keep width readable */
        .content-wrapper {
            width: 100%;
            max-width: 800px;
            margin: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 100%;
        }

        header { margin-bottom: 2vh; }

        /* 復活させたタイトル文字 */
        h1 {
            font-size: clamp(0.9rem, 2vh, 1.2rem);
            letter-spacing: 4px;
            text-transform: uppercase;
            color: #ffffff;
            margin: 0 0 0.5vh 0;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0,0,0,0.6);
            display: block;
            opacity: 1;
        }

        /* Natural Rainbow Animation */
        .big-year {
            font-size: clamp(3.5rem, 12vh, 8rem); /* 画面高さにも依存させる */
            font-weight: 900;
            line-height: 1;
            margin: 0;
            /* HSL based gradient for natural transition */
            background: linear-gradient(to right, 
                hsl(0, 100%, 50%), 
                hsl(60, 100%, 50%), 
                hsl(120, 100%, 50%), 
                hsl(180, 100%, 50%), 
                hsl(240, 100%, 50%), 
                hsl(300, 100%, 50%), 
                hsl(360, 100%, 50%));
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: naturalRainbow 5s linear infinite;
            filter: drop-shadow(0 0 20px rgba(255,255,255,0.1));
        }

        @keyframes naturalRainbow {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        /* Current Time */
        .current-time-wrapper {
            margin-bottom: 2.5vh;
            padding: 0.8vh 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 50px;
            display: inline-block;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #current-datetime { font-size: clamp(0.9rem, 2vh, 1.1rem); font-weight: 300; letter-spacing: 1px; }
        .time-display { font-weight: 700; font-feature-settings: "tnum"; color: #fff; margin-left: 10px; }

        /* Countdown Grid */
        #countdown {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: clamp(8px, 2vw, 15px);
            margin-bottom: 3vh;
        }

        .time-unit {
            background: rgba(0,0,0,0.3);
            padding: 1.5vh 1vw;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: border-color 0.3s;
            will-change: transform, border-color;
        }
        
        /* 1 Minute Alert Style */
        .last-minute-alert .time-unit {
            border-color: rgba(255, 51, 51, 0.5);
            background: rgba(50, 0, 0, 0.4);
            animation: pulse-border 1s infinite;
        }
        .last-minute-alert .number {
            color: var(--danger-color);
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        @keyframes pulse-border {
            0% { border-color: rgba(255, 51, 51, 0.3); transform: scale(1); }
            50% { border-color: rgba(255, 51, 51, 0.8); transform: scale(1.02); }
            100% { border-color: rgba(255, 51, 51, 0.3); transform: scale(1); }
        }
        
        .time-unit .number {
            font-size: clamp(1.8rem, 4vh, 3.5rem);
            font-weight: 700;
            line-height: 1.1;
            font-feature-settings: "tnum";
            color: #fff;
        }
        .time-unit .label {
            font-size: clamp(0.6rem, 1.5vh, 0.8rem);
            text-transform: uppercase;
            color: var(--text-muted);
            margin-top: 5px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        /* New Year Message */
        #new-year-message {
            display: none;
            margin-bottom: 3vh;
            animation: floatUp 1s ease-out;
        }
        @keyframes floatUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .ny-title {
            font-size: clamp(2rem, 5vh, 4rem);
            color: #fff;
            text-shadow: 0 0 30px #ff00de, 0 0 60px #7b2cbf;
            margin: 0;
            line-height: 1.2;
        }
        .ny-subtitle {
            font-size: clamp(1rem, 2.5vh, 1.8rem);
            color: #e0aaff;
            margin-top: 1.5vh;
            font-weight: 400;
            letter-spacing: 2px;
            font-style: normal;
        }

        /* Celebration Status (Inside Card) */
        #celebration-status {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.8vh 25px;
            border-radius: 50px;
            font-size: clamp(1rem, 2vh, 1.2rem);
            font-weight: 600;
            color: #fff;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            margin-top: 2vh;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }
        .pulsing-dot {
            width: 12px; height: 12px;
            background: #ff0055;
            border-radius: 50%;
            animation: pulse-dot 1s infinite;
            box-shadow: 0 0 10px #ff0055;
        }
        @keyframes pulse-dot { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1); } }

        /* Progress Bar */
        .progress-section {
            margin-bottom: 2vh;
            text-align: left;
            background: var(--input-bg);
            padding: 2vh 20px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 0.8vh;
        }

        .progress-container {
            height: clamp(10px, 1.5vh, 16px);
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
            margin-bottom: 1vh;
        }

        .progress-bar {
            height: 100%;
            background: var(--accent-gradient);
            width: 0%;
            box-shadow: 0 0 20px rgba(157, 78, 221, 0.8);
            position: relative;
            will-change: width;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            transform: translateX(-100%);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer { 100% { transform: translateX(100%); } }

        .progress-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .percent-display {
            font-size: clamp(1.1rem, 2vh, 1.3rem);
            font-weight: 700;
            color: var(--success-color);
            font-feature-settings: "tnum";
            text-shadow: 0 0 10px rgba(46, 204, 113, 0.3);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 80px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        /* Buttons */
        .controls-row {
            display: flex;
            gap: 15px;
            margin-bottom: 2vh;
        }
        
        .action-btn {
            background: var(--accent-gradient);
            color: white;
            border: none;
            padding: 1.8vh 20px;
            width: 100%;
            border-radius: 16px;
            font-family: 'Outfit', sans-serif;
            font-weight: 700;
            font-size: clamp(0.9rem, 2vh, 1rem);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .action-btn:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(157, 78, 221, 0.6); }
        .action-btn:active { transform: scale(0.98); }
        
        .secondary-btn {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
        }
        .secondary-btn:hover { background: rgba(255,255,255,0.2); }
        
        .toggle-btn {
            flex: 1;
            padding: 1.5vh 14px;
            border-radius: 14px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: clamp(0.85rem, 1.8vh, 1rem);
        }
        .toggle-btn.active {
            background: rgba(46, 204, 113, 0.2);
            border-color: var(--success-color);
            color: var(--success-color);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.2);
        }

        /* Visibility Toggle */
        .visibility-toggle {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        .visibility-toggle:hover { transform: translateX(-50%) scale(1.05); background: #000; }

        @media (max-width: 600px) {
            .container { padding: 2vh 15px; }
            #countdown { gap: 8px; }
            .time-unit { padding: 1.5vh 5px; }
            .ny-title { font-size: 2.5rem; }
            .action-btn { font-size: 0.9rem; }
            input[type="range"] { width: 60px; }
        }
        
        /* 縦が極端に短い画面用の調整 */
        @media (max-height: 700px) {
            .big-year { font-size: 12vh; }
            #countdown { margin-bottom: 2vh; }
            .time-unit .number { font-size: 4vh; }
            .progress-section { padding: 1.5vh 15px; margin-bottom: 1.5vh; }
            .action-btn { padding: 1.5vh 20px; }
            header { margin-bottom: 1vh; }
            .current-time-wrapper { margin-bottom: 1.5vh; }
            .toggle-btn { padding: 1vh 10px; }
        }
    </style>
</head>
<body>

<canvas id="fireworks-canvas"></canvas>

<!-- Full Screen Glass Card -->
<div class="container" id="main-card">
    <div class="content-wrapper">
        <header>
            <h1>New Year Countdown</h1>
            <div class="big-year" id="target-year-display">2026</div>
        </header>

        <div class="current-time-wrapper">
            <div id="current-datetime"></div>
        </div>

        <!-- Main Countdown -->
        <div id="countdown-container">
            <div id="countdown">
                <div class="time-unit"><span class="number" id="days">0</span><span class="label">Days</span></div>
                <div class="time-unit"><span class="number" id="hours">0</span><span class="label">Hours</span></div>
                <div class="time-unit"><span class="number" id="minutes">0</span><span class="label">Mins</span></div>
                <div class="time-unit"><span class="number" id="seconds">00</span><span class="label">Secs</span></div>
            </div>
            
            <!-- Message & Show Timer (Inside Card) -->
            <div id="new-year-message">
                <h2 class="ny-title">HAPPY NEW YEAR!</h2>
                <div class="ny-subtitle">A New Era Has Begun.</div>
                
                <div id="celebration-status">
                    <span class="pulsing-dot"></span>
                    <span id="fw-end-text">演出終了まで: --:--:--</span>
                </div>
            </div>
        </div>

        <!-- Progress Bar Section -->
        <div class="progress-section">
            <div class="progress-labels">
                <span id="label-start-date">Jan 1</span>
                <span id="label-end-date">Jan 1</span>
            </div>
            <div class="progress-container">
                <div class="progress-bar" id="year-progress-bar"></div>
            </div>
            <div class="progress-controls">
                <div class="percent-display" id="progress-percent-text">0.0000%</div>
                <div class="digits-slider-container">
                    <span style="font-size:0.7rem; color:var(--text-muted); margin-right:5px;">桁数</span>
                    <input type="range" id="percent-precision" min="0" max="8" value="4">
                </div>
            </div>
        </div>

        <div class="controls-row">
            <button id="sound-toggle-btn" class="toggle-btn active">
                <i class="bi bi-volume-up-fill" id="sound-icon"></i> サウンド: ON
            </button>
        </div>

        <div style="display: flex; flex-direction: column; gap: 1.5vh;">
            <button class="action-btn" id="test-fireworks-btn">
                <i class="bi bi-stars"></i> 花火・歓声をテスト (即時)
            </button>
            <button class="action-btn secondary-btn" id="test-newyear-btn">
                <i class="bi bi-clock-history"></i> 新年10秒前からテスト
            </button>
        </div>
    </div>
</div>

<button class="visibility-toggle" id="visibility-toggle">
    <i class="bi bi-eye-slash"></i> 非表示
</button>

<script>
    /**
     * ------------------------------------------------------------------
     *  Sound Engine (Realistic Audio Synthesis)
     * ------------------------------------------------------------------
     */
    class AudioEngine {
        constructor() {
            this.ctx = null;
            this.enabled = true; // Default ON
            this.masterGain = null;
            this.cheerLoop = null;
            this.initialized = false;
        }

        init() {
            if (this.initialized) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.4; // Master Volume
            this.masterGain.connect(this.ctx.destination);
            
            // Reverb Simulation
            this.convolver = this.ctx.createConvolver();
            this.generateImpulse();
            this.convolver.connect(this.masterGain);
            
            this.initialized = true;
            if (this.ctx.state === 'suspended') this.ctx.resume();
        }

        generateImpulse() {
            const rate = this.ctx.sampleRate;
            const length = rate * 2.0; 
            const impulse = this.ctx.createBuffer(2, length, rate);
            const L = impulse.getChannelData(0);
            const R = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                const decay = Math.pow(1 - i / length, 4);
                L[i] = (Math.random() * 2 - 1) * decay;
                R[i] = (Math.random() * 2 - 1) * decay;
            }
            this.convolver.buffer = impulse;
        }

        toggle() {
            this.enabled = !this.enabled;
            if (this.enabled && !this.initialized) this.init();
            if (this.enabled && this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            if (!this.enabled && this.cheerLoop) this.stopCheer();
            return this.enabled;
        }

        playExplosion(size = 1) {
            if (!this.enabled || !this.ctx) return;
            const t = this.ctx.currentTime;

            // Thud
            const osc = this.ctx.createOscillator();
            const oscGain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(120, t);
            osc.frequency.exponentialRampToValueAtTime(10, t + 0.3 * size);
            oscGain.gain.setValueAtTime(1.0, t);
            oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5 * size);
            osc.connect(oscGain);
            oscGain.connect(this.masterGain);
            osc.start(t);
            osc.stop(t + 0.6);

            // Crack
            const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.5, this.ctx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for(let i=0; i<data.length; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = this.ctx.createBufferSource();
            noise.buffer = noiseBuffer;
            const noiseFilter = this.ctx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.value = 1000;
            
            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(0.8, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3 * size);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(this.masterGain);
            noiseGain.connect(this.convolver);
            noise.start(t);
        }

        playCountdownPulse() {
            if (!this.enabled || !this.ctx) return;
            const t = this.ctx.currentTime;
            
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.frequency.setValueAtTime(150, t);
            osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
            g.gain.setValueAtTime(1, t);
            g.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            
            osc.connect(g);
            g.connect(this.masterGain);
            osc.start(t);
            osc.stop(t + 0.5);
        }

        startCheer() {
            if (!this.enabled || !this.ctx || this.cheerLoop) return;
            
            const bufferSize = this.ctx.sampleRate * 5; 
            const buffer = this.ctx.createBuffer(2, bufferSize, this.ctx.sampleRate);
            for (let c = 0; c < 2; c++) {
                const data = buffer.getChannelData(c);
                let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                    data[i] *= 0.11; 
                    b6 = white * 0.115926;
                }
            }

            this.cheerSource = this.ctx.createBufferSource();
            this.cheerSource.buffer = buffer;
            this.cheerSource.loop = true;

            const filter = this.ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 800;
            filter.Q.value = 0.5;

            this.cheerGain = this.ctx.createGain();
            this.cheerGain.gain.value = 0;

            this.cheerSource.connect(filter);
            filter.connect(this.cheerGain);
            this.cheerGain.connect(this.masterGain);
            
            this.cheerSource.start();
            
            const t = this.ctx.currentTime;
            this.cheerGain.gain.linearRampToValueAtTime(0.5, t + 4);
            
            this.cheerLoop = true;
        }

        stopCheer() {
            if (this.cheerSource) {
                const t = this.ctx.currentTime;
                this.cheerGain.gain.cancelScheduledValues(t);
                this.cheerGain.gain.linearRampToValueAtTime(0, t + 2);
                setTimeout(() => {
                    if (this.cheerSource) this.cheerSource.stop();
                    this.cheerLoop = false;
                    this.cheerSource = null;
                }, 2000);
            }
        }
    }

    /**
     * ------------------------------------------------------------------
     *  Fireworks Engine (Optimized High Quality)
     * ------------------------------------------------------------------
     */
    const canvas = document.getElementById('fireworks-canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const audio = new AudioEngine();
    
    let fireworks = [];
    let particles = [];
    let animationId;
    let isActive = false;
    let stopping = false;

    function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
    }
    window.addEventListener('resize', resize);
    resize();

    class Firework {
        constructor(isFinale = false) {
            this.x = Math.random() * window.innerWidth;
            this.y = window.innerHeight;
            this.targetY = window.innerHeight * 0.1 + Math.random() * (window.innerHeight * 0.5);
            this.speed = 8 + Math.random() * 5;
            this.angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.2;
            this.vx = Math.cos(this.angle) * this.speed;
            this.vy = Math.sin(this.angle) * this.speed;
            this.hue = Math.random() * 360;
            this.brightness = Math.random() * 30 + 70;
            this.dead = false;
            this.isFinale = isFinale;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.15; // Gravity
            
            if (this.vy >= 0 || this.y <= this.targetY) {
                this.dead = true;
                explode(this.x, this.y, this.hue, this.isFinale);
            }
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${this.hue}, 100%, ${this.brightness}%)`;
            ctx.fill();
        }
    }

    class Particle {
        constructor(x, y, hue, isFinale) {
            this.x = x;
            this.y = y;
            this.hue = hue + (Math.random() - 0.5) * 40;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * (isFinale ? 15 : 8) + 1;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.friction = 0.95;
            this.gravity = 0.2;
            this.alpha = 1;
            this.decay = Math.random() * 0.015 + 0.005;
            this.brightness = Math.random() * 20 + 60;
        }
        update() {
            this.vx *= this.friction;
            this.vy *= this.friction;
            this.vy += this.gravity;
            this.x += this.vx;
            this.y += this.vy;
            this.alpha -= this.decay;
            return this.alpha > 0;
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${this.hue}, 100%, ${this.brightness}%, ${this.alpha})`;
            ctx.fill();
        }
    }

    function explode(x, y, hue, isFinale) {
        const count = isFinale ? 200 : 80;
        for (let i = 0; i < count; i++) {
            particles.push(new Particle(x, y, hue, isFinale));
        }
        audio.playExplosion(isFinale ? 2 : 1);
    }

    function loop() {
        if (!isActive && fireworks.length === 0 && particles.length === 0) {
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            cancelAnimationFrame(animationId);
            animationId = null;
            return;
        }

        animationId = requestAnimationFrame(loop);
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

        if (isActive && !stopping) {
            const density = 0.2; 
            for(let i=0; i<3; i++) {
                if (Math.random() < density) fireworks.push(new Firework(Math.random() < 0.1));
            }
        }

        fireworks = fireworks.filter(fw => {
            fw.update();
            fw.draw();
            return !fw.dead;
        });

        particles = particles.filter(p => {
            const alive = p.update();
            if (alive) p.draw();
            return alive;
        });
    }

    function startFireworks() {
        if (!animationId) {
            isActive = true;
            stopping = false;
            fireworks = [];
            particles = [];
            loop();
        } else {
            isActive = true;
            stopping = false;
        }
        audio.startCheer();
    }

    function stopFireworks() {
        stopping = true;
        isActive = false;
        audio.stopCheer();
    }

    /**
     * ------------------------------------------------------------------
     *  Main Application Logic (Performance Optimized)
     * ------------------------------------------------------------------
     */
    const els = {
        now: document.getElementById('current-datetime'),
        targetYear: document.getElementById('target-year-display'),
        days: document.getElementById('days'),
        hours: document.getElementById('hours'),
        mins: document.getElementById('minutes'),
        secs: document.getElementById('seconds'),
        bar: document.getElementById('year-progress-bar'),
        pctText: document.getElementById('progress-percent-text'),
        slider: document.getElementById('percent-precision'),
        startLabel: document.getElementById('label-start-date'),
        endLabel: document.getElementById('label-end-date'),
        countdownContainer: document.getElementById('countdown'),
        newYearMsg: document.getElementById('new-year-message'),
        fwText: document.getElementById('fw-end-text'),
        card: document.getElementById('main-card'),
        soundBtn: document.getElementById('sound-toggle-btn'),
        testFwBtn: document.getElementById('test-fireworks-btn'),
        testNyBtn: document.getElementById('test-newyear-btn'),
        visibilityBtn: document.getElementById('visibility-toggle')
    };

    let targetYear = new Date().getFullYear() + 1;
    let isCelebrating = false;
    let virtualOffset = 0; 
    let precision = 4;
    let lastSecond = -1;
    let celebrationEndTime = 0;

    let cache = {
        timeStr: '',
        pctStr: '',
        d: '', h: '', m: '', s: '',
        fwStr: '',
        alertMode: false
    };

    // Initialize Dates
    els.targetYear.textContent = targetYear;
    const currentYearVal = new Date().getFullYear();
    const nextYearVal = currentYearVal + 1;
    const dateFmt = new Intl.DateTimeFormat('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' });
    els.startLabel.textContent = dateFmt.format(new Date(currentYearVal, 0, 1));
    els.endLabel.textContent = dateFmt.format(new Date(nextYearVal, 0, 1));

    // Sound Toggle
    els.soundBtn.addEventListener('click', () => {
        const enabled = audio.toggle();
        els.soundBtn.classList.toggle('active', enabled);
        els.soundBtn.innerHTML = enabled 
            ? '<i class="bi bi-volume-up-fill"></i> サウンド: ON' 
            : '<i class="bi bi-volume-mute-fill"></i> サウンド: OFF';
    });

    // Precision Slider
    els.slider.addEventListener('input', (e) => {
        precision = parseInt(e.target.value);
    });

    // Visibility Toggle
    els.visibilityBtn.addEventListener('click', () => {
        els.card.classList.toggle('hidden');
        els.visibilityBtn.innerHTML = els.card.classList.contains('hidden') 
            ? '<i class="bi bi-eye"></i> 表示' 
            : '<i class="bi bi-eye-slash"></i> 非表示';
    });

    // Main Update Loop
    function update() {
        const nowMs = Date.now() + virtualOffset;
        const now = new Date(nowMs);
        const targetDate = new Date(targetYear, 0, 1, 0, 0, 0);
        let diff = targetDate - now;

        // --- Clock Display (Optimized) ---
        const timeStr = now.toLocaleTimeString('ja-JP', { hour12: false });
        if (timeStr !== cache.timeStr) {
            const dateStr = now.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'short' });
            els.now.innerHTML = `${dateStr} <span class="time-display">${timeStr}</span>`;
            cache.timeStr = timeStr;
        }

        // --- Progress Bar (Optimized) ---
        const startOfYear = new Date(now.getFullYear(), 0, 1).getTime();
        const endOfYear = new Date(now.getFullYear() + 1, 0, 1).getTime();
        const total = endOfYear - startOfYear;
        const elapsed = now.getTime() - startOfYear;
        let pct = (elapsed / total) * 100;
        if (pct > 100) pct = 100; 
        
        const pctStr = pct.toFixed(precision);
        if (pctStr !== cache.pctStr) {
            els.bar.style.width = `${pct}%`;
            els.pctText.textContent = `${pctStr}%`;
            cache.pctStr = pctStr;
        }

        // --- Logic: Before New Year ---
        if (diff > 0) {
            isCelebrating = false;
            if (els.countdownContainer.style.display === 'none') {
                 els.countdownContainer.style.display = 'grid';
                 els.newYearMsg.style.display = 'none';
            }

            const d = Math.floor(diff / (1000 * 60 * 60 * 24));
            const h = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const m = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const s = Math.floor((diff % (1000 * 60)) / 1000);

            // DOM Updates only on change
            if (cache.d !== d) { els.days.textContent = d; cache.d = d; }
            if (cache.h !== h) { els.hours.textContent = String(h).padStart(2, '0'); cache.h = h; }
            if (cache.m !== m) { els.mins.textContent = String(m).padStart(2, '0'); cache.m = m; }
            if (cache.s !== s) { els.secs.textContent = String(s).padStart(2, '0'); cache.s = s; }

            // --- 1 Minute Alert (Red Pulse) ---
            if (diff <= 60000) {
                if (!cache.alertMode) {
                    els.countdownContainer.classList.add('last-minute-alert');
                    cache.alertMode = true;
                }
            } else {
                if (cache.alertMode) {
                    els.countdownContainer.classList.remove('last-minute-alert');
                    cache.alertMode = false;
                }
            }

            // --- Last 10 Seconds Audio ---
            if (diff <= 10500) {
                if (s !== lastSecond) {
                    audio.playCountdownPulse();
                    lastSecond = s;
                }
            }

        } else {
            // --- Logic: New Year / Celebration Mode ---
            if (!isCelebrating) {
                isCelebrating = true;
                celebrationEndTime = nowMs + (60 * 60 * 1000);
                els.countdownContainer.style.display = 'none';
                els.newYearMsg.style.display = 'block';
                startFireworks(); 
                for(let i=0; i<5; i++) setTimeout(() => audio.playExplosion(2), i*200);
            }

            let fwRemaining = celebrationEndTime - nowMs;
            
            if (fwRemaining > 0) {
                const fH = Math.floor(fwRemaining / (1000 * 60 * 60));
                const fM = Math.floor((fwRemaining % (1000 * 60 * 60)) / (1000 * 60));
                const fS = Math.floor((fwRemaining % (1000 * 60)) / 1000);
                const fwStr = `演出終了まで: ${String(fH).padStart(2,'0')}:${String(fM).padStart(2,'0')}:${String(fS).padStart(2,'0')}`;
                
                if (fwStr !== cache.fwStr) {
                    els.fwText.textContent = fwStr;
                    cache.fwStr = fwStr;
                }
            } else {
                if (els.fwText.textContent !== "終了") {
                    els.fwText.textContent = "終了";
                    stopFireworks();
                }
            }
        }

        requestAnimationFrame(update);
    }

    // --- Buttons Logic ---

    // 1. Test Fireworks Immediately (1 Hour from NOW)
    els.testFwBtn.addEventListener('click', () => {
        audio.init(); 
        if (isActive) {
            stopFireworks();
            return;
        }
        celebrationEndTime = Date.now() + (60 * 60 * 1000);
        els.countdownContainer.style.display = 'none';
        els.newYearMsg.style.display = 'block';
        startFireworks();
    });

    // 2. Test New Year (-10 seconds)
    els.testNyBtn.addEventListener('click', () => {
        audio.init();
        isCelebrating = false;
        stopFireworks(); 
        els.card.classList.remove('hidden');

        // Reset Cache to ensure immediate redraw
        cache = { timeStr: '', pctStr: '', d: '', h: '', m: '', s: '', fwStr: '', alertMode: false };
        els.countdownContainer.classList.remove('last-minute-alert');

        const realNow = Date.now();
        const targetDate = new Date(targetYear, 0, 1, 0, 0, 0).getTime();
        virtualOffset = (targetDate - 10000) - realNow;
    });

    // Start
    update();

</script>
</body>
</html>
